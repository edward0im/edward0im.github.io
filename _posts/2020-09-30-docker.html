---
layout: post
title: (Linux) Docker 사용법 및 다양한 옵션 설명
description: 
date: 2020-09-30
categories: [Technology]
tag: [Linux, Docker]
use_math: true
comments: true
---
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2af43e8">1. Introduction</a></li>
<li><a href="#org0927b88">2. How to setup</a>
<ul>
<li><a href="#org042c9e9">2.1. w/o sudo command</a></li>
<li><a href="#org8bd5758">2.2. Bash autocompletion</a></li>
<li><a href="#orga43e558">2.3. Connect to the internet</a></li>
<li><a href="#orgeed4007">2.4. nvidia-docker</a></li>
</ul>
</li>
<li><a href="#org6a1a86c">3. Mostly used features</a>
<ul>
<li><a href="#orgb701d3f">3.1. commands</a>
<ul>
<li><a href="#org04a91a7">3.1.1. <code>rm</code></a></li>
<li><a href="#orge89772b">3.1.2. <code>rmi</code></a></li>
<li><a href="#org52b434a">3.1.3. <code>ps</code></a></li>
<li><a href="#orgd993110">3.1.4. <code>images</code></a></li>
<li><a href="#orgc6effb8">3.1.5. <code>attach</code></a></li>
<li><a href="#orgd97e625">3.1.6. <code>run</code></a></li>
<li><a href="#org155c827">3.1.7. <code>commit</code></a></li>
<li><a href="#orgefef859">3.1.8. <code>build</code></a>
<ul>
<li><a href="#org73afb3e">3.1.8.1. Dockerfile</a></li>
</ul>
</li>
<li><a href="#orgfd39baa">3.1.9. <code>push, pull</code></a>
<ul>
<li><a href="#orgcad75ad">3.1.9.1. Docker hub</a></li>
</ul>
</li>
<li><a href="#orgaea77e2">3.1.10. <code>&lt;C-p&gt; &lt;C-q&gt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf163f42">4. References</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org2af43e8" class="outline-2">
<h2 id="org2af43e8"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
본 포스트에서는 Docker의 사용법 및 다양한 옵션들에 대해 설명한다. Docker는 컨테이너라는 가상의 이미지를 생성하여 메인 운영체제 시스템과 리소스는 공유하지만 버전에 독립적인 프로그램을 돌릴 수 있는 가상화 프로그램이다. 리눅스를 사용하면서 버전 문제로 인해 빌드에 실패해 본 경험이 있는 사용자들에게 Docker를 추천한다. 본 포스트에서 설명하는 모든 내용은 우분투 18.04 LTS 버전에서 정상적으로 작동하였다.
</p>
</div>
</div>
<div id="outline-container-org0927b88" class="outline-2">
<h2 id="org0927b88"><span class="section-number-2">2</span> How to setup</h2>
<div class="outline-text-2" id="text-2">
<p>
Ubuntu 18.04 LTS 환경에서 docker는 다음 명령어를 통해 간단하게 설치할 수 있다.
</p>
<div class="org-src-container">
<pre class="src src-sh">$ sudo apt install docker*
</pre>
</div>
</div>
<div id="outline-container-org042c9e9" class="outline-3">
<h3 id="org042c9e9"><span class="section-number-3">2.1</span> w/o sudo command</h3>
<div class="outline-text-3" id="text-2-1">
<p>
우분투에서 docker를 처음 설치하고 실행하면 매번 실행할 때마다 sudo 명령어를 입력해줘야 한다. 이를 sudo 명령어없이 편하게 사용하려면 현재 계정을 docker 그룹에 포함시키면 된다. 명령어는 아래와 같다.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Add user to docker group.</span>
$ sudo usermod -aG docker ${<span class="org-variable-name">USER</span>}

<span class="org-comment-delimiter"># </span><span class="org-comment">Restart docker service.</span>
$ sudo service docker restart

<span class="org-comment-delimiter"># </span><span class="org-comment">&#54788;&#51116; &#44228;&#51221;&#51012; &#47196;&#44536;&#50500;&#50883; &#46608;&#45716; &#51116;&#48512;&#54021;&#54616;&#44256; &#51116;&#51217;&#49549;&#54616;&#47732; &#51201;&#50857;&#46108;&#45796;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8bd5758" class="outline-3">
<h3 id="org8bd5758"><span class="section-number-3">2.2</span> Bash autocompletion</h3>
<div class="outline-text-3" id="text-2-2">
<p>
필자가 테스트해본 결과 Ubuntu 18.04 LTS에서 설치한 <b>docker 19.03.06 버전은 별도의 과정없이 자동완성이 되는 것을 확인하였다.</b> 만약 자신의 docker 내부 bash에서 자동완성이 되지 않는 경우 아래 절차대로 실행하면 자동완성이 설정된다. 하지만, 아래 코드를 수행해도 <code>apt</code> 관련 자동완성은 되지 않는다.
</p>
<div class="org-src-container">
<pre class="src src-sh">$ apt install bash-completion

<span class="org-comment-delimiter"># </span><span class="org-comment">download bash completion file into /etc/bash_completion.d/ </span>
$ curl https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh

<span class="org-comment-delimiter"># </span><span class="org-comment">/etc/.bash.bashrc &#54028;&#51068;&#51012; &#50676;&#44256; &#50500;&#47000; &#53076;&#46300;&#47484; &#51452;&#49437; &#54644;&#51228;&#54620;&#45796;.</span>
$ vim /etc/bash.bashrc

<span class="org-keyword">if</span> <span class="org-negation-char">!</span> shopt -oq posix; <span class="org-keyword">then</span>
    <span class="org-keyword">if</span> [ -f /usr/share/bash-completion/bash_completion ]; <span class="org-keyword">then</span>
        . /usr/share/bash-completion/bash_completion
    <span class="org-keyword">elif</span> [ -f /etc/bash_completion ]; <span class="org-keyword">then</span>
        . /etc/bash_completion
    <span class="org-keyword">fi</span>
<span class="org-keyword">fi</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">~/.bashrc &#50640;&#46020; &#48708;&#49847;&#54620; completion &#53076;&#46300;&#44032; &#51080;&#45716;&#45936; &#54644;&#45817; &#53076;&#46300;&#47484; &#51452;&#49437; &#54644;&#51228;&#54620;&#45796;.</span>
<span class="org-keyword">if</span> [ -f /etc/bash_completion ] &amp;&amp; <span class="org-negation-char">!</span> shopt -oq posix; <span class="org-keyword">then</span>
    . /etc/bash_completion
<span class="org-keyword">fi</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">&#48320;&#44221;&#49324;&#54637;&#51012; &#51201;&#50857;&#54620;&#45796;. </span>
$ source /etc/bash.bashrc
$ source ~/.bashrc
</pre>
</div>
</div>
</div>

<div id="outline-container-orga43e558" class="outline-3">
<h3 id="orga43e558"><span class="section-number-3">2.3</span> Connect to the internet</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Docker 컨테이너는 NAT 기술을 사용하여 외부 네트워크로 통신한다. 실제 인터넷 선은 하나 밖에 제공되어 있지 않고 그 선을 통해 데이터가 나가야 하기 때문에 Linux의 <code>iptables</code> 명령을 사용해서 해당 브릿지 인터페이스에 MASQUERADE 기능을 부여하거나 SNAT 값을 줘야 한다. <b>해당 섹션의 내용 또한 필자는 아래 과정을 진행하지 않고도 docker 19.03.06 버전에서 인터넷 사용이 가능하였다.</b> 만약 인터넷이 정상적으로 동작하지 않는 경우 아래 과정을 진행하면 된다.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">host &#47672;&#49888;&#50640;&#49436; &#50500;&#47000; &#47749;&#47161;&#50612;&#47484; &#49892;&#54665;&#54620;&#45796;. &#50500;&#47000; &#47749;&#47161;&#50612;&#47484; &#53685;&#54644; iptables&#50640; NAT &#51221;&#48372;&#47484; &#51077;&#47141;&#54620;&#45796;</span>
$ sudo iptables -t nat -A PREROUTING -d 0.0.0.0/0 -m addrtype --dst-type LOCAL -j DOCKER
$ sudo iptables -t nat -A OUTPUT -m addrtype --dst-type LOCAL -j DOCKER
$ sudo iptables -t nat -A POSTROUTING -s 172.17.0.0/16 -j MASQUERADE

<span class="org-comment-delimiter"># </span><span class="org-comment">&#47749;&#47161;&#50612;&#44032; &#51221;&#49345;&#51201;&#51004;&#47196; &#51089;&#46041;&#54664;&#45716;&#51648; &#54869;&#51064;&#54620;&#45796;.</span>
$ sudo iptables -t nat -L

Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  --  anywhere            !127.0.0.0/8          ADDRTYPE match dst-type LOCAL
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
MASQUERADE  all  --  172.17.0.0/16        anywhere            
MASQUERADE  all  --  172.17.0.0/16        anywhere            

Chain DOCKER (4 references)
target     prot opt source               destination         
RETURN     all  --  anywhere             anywhere  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeed4007" class="outline-3">
<h3 id="orgeed4007"><span class="section-number-3">2.4</span> nvidia-docker</h3>
<div class="outline-text-3" id="text-2-4">
<p>
<code>nvidia-docker</code> 는 호스트 컴퓨터에 Nvidia 드라이버가 있을 경우 컨테이너에서 GPU를 사용할 수 있도록 해주는 프로그램이다. <b>docker가 최근 19.03.5 버전부터 자체적으로 nvidia-docker 명령어를 흡수하면서 <code>--gpus</code> 옵션으로 보다 간단하게 사용할 수 있게 되었다.</b>
</p>

<p>
자세한 내용은 <a href="https://github.com/NVIDIA/nvidia-docker">공식 github</a>에 소개되어 있다.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Add the package repositories</span>
$ curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
$ <span class="org-variable-name">distribution</span>=$(. /etc/os-release;<span class="org-builtin">echo</span> $<span class="org-variable-name">ID</span>$<span class="org-variable-name">VERSION_ID</span>)
$ curl -s -L https://nvidia.github.io/nvidia-docker/$<span class="org-variable-name">distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
$ sudo apt update

<span class="org-comment-delimiter"># </span><span class="org-comment">Install nvidia-docker2 and reload the Docker daemon configuration</span>
$ sudo apt install -y nvidia-docker2
$ sudo pkill -SIGHUP dockerd

<span class="org-comment-delimiter"># </span><span class="org-comment">Test nvidia-smi with the latest official CUDA image</span>
$ docker run --runtime=nvidia --rm nvidia/cuda:9.0-base nvidia-smi
</pre>
</div>
<p>
만약 설치 도중 <code>docker-ce</code> 의존성 에러가 나는 경우 다음 코드를 추가적으로 실행해준다. 
</p>
<div class="org-src-container">
<pre class="src src-sh">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88
$ sudo add-apt-repository <span class="org-string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable</span>
<span class="org-string">$ sudo apt update</span>
<span class="org-string">$ sudo apt install docker-ce</span>
<span class="org-string">$ sudo service docker restart</span>
</pre>
</div>

<p>
<code>nvidia-docker</code> 명령어는 다음과 같이 <code>--gpus all</code> 을 통해 사용할 수 있다. 만약 non-cuda 이미지에서 GPU를 사용하고 싶을 경우 아래와 같은 명령어를 사용하면 된다. 
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">-e NVIDIA_VISIBLE_DEVICES=all &#51012; &#51077;&#47141;&#54616;&#47732; non-CUDA &#51060;&#48120;&#51648;&#50640;&#49436;&#46020; gpu&#47484; &#49324;&#50857;&#54624; &#49688; &#51080;&#45716; &#46319;</span>
$ docker run --gpus all -e <span class="org-variable-name">NVIDIA_VISIBLE_DEVICES</span>=all -it --name ros_nvidia2 edward0im/1804:scratch
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6a1a86c" class="outline-2">
<h2 id="org6a1a86c"><span class="section-number-2">3</span> Mostly used features</h2>
<div class="outline-text-2" id="text-3">
<p>
docker에는 많은 명령어들이 존재하지만 해당 섹션에서는 필자가 자주 사용하는 docker 명령어들을 위주로 정리하였다. Control 키바인딩은 <code>&lt;C-{...}&gt;</code> 로 표시하였다.
</p>
</div>
<div id="outline-container-orgb701d3f" class="outline-3">
<h3 id="orgb701d3f"><span class="section-number-3">3.1</span> commands</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org04a91a7" class="outline-4">
<h4 id="org04a91a7"><span class="section-number-4">3.1.1</span> <code>rm</code></h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
특정 컨테이너 삭제
</p>
</div>
</div>
<div id="outline-container-orge89772b" class="outline-4">
<h4 id="orge89772b"><span class="section-number-4">3.1.2</span> <code>rmi</code></h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
특정 이미지 삭제
</p>
</div>
</div>
<div id="outline-container-org52b434a" class="outline-4">
<h4 id="org52b434a"><span class="section-number-4">3.1.3</span> <code>ps</code></h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
현재 실행 중인 컨테이너 목록 검색
</p>
</div>
</div>
<div id="outline-container-orgd993110" class="outline-4">
<h4 id="orgd993110"><span class="section-number-4">3.1.4</span> <code>images</code></h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
이미지 목록 검색
</p>
</div>
</div>
<div id="outline-container-orgc6effb8" class="outline-4">
<h4 id="orgc6effb8"><span class="section-number-4">3.1.5</span> <code>attach</code></h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
현재 실행 중인 컨테이너에 접속
</p>
</div>
</div>
<div id="outline-container-orgd97e625" class="outline-4">
<h4 id="orgd97e625"><span class="section-number-4">3.1.6</span> <code>run</code></h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
이미지를 컨테이너로 실행
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">docker run&#51008; &#53552;&#48120;&#45328;&#50640;&#49436; &#48148;&#47196; &#49892;&#54665;&#54616;&#44592;&#48372;&#45796; &#48372;&#53685; shell script (.sh) &#54028;&#51068;&#47196; &#51200;&#51109;&#54616;&#50668; &#54620; &#48264;&#50640; &#49892;&#54665;&#54620;&#45796;.</span>
$ docker run -it --name ros -v ~/docker:/root/data edward0im/1804:scratch
$ docker run -i -t --name hello ubuntu:18.04 /bin/bash
$ docker run -i --net host --name hello -t ubuntu:18.04 /bin/bash
<span class="org-comment-delimiter"># </span><span class="org-comment">i : interactive</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">t : pseudo-tty</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--net :</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">--name : &#51060;&#47492;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org155c827" class="outline-4">
<h4 id="org155c827"><span class="section-number-4">3.1.7</span> <code>commit</code></h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
현재 컨테이너의 변경사항을 이미지로 저장
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">scratch &#52968;&#53580;&#51060;&#45320;&#47484; edward0im/1804:scratch &#51060;&#48120;&#51648;&#47196; &#51200;&#51109;&#54620;&#45796;. &#51089;&#49457;&#51088;&#45716; edward0im&#51060;&#44256; &#47700;&#49464;&#51648;&#45716; -m &#50741;&#49496;&#51012; &#53685;&#54644; &#51077;&#47141;&#54620;&#45796;.</span>
$ docker commit -a <span class="org-string">"edward0im"</span> -m <span class="org-string">"catkin_ws installed"</span> scratch edward0im/1804:scratch
</pre>
</div>
</div>
</div>
<div id="outline-container-orgefef859" class="outline-4">
<h4 id="orgefef859"><span class="section-number-4">3.1.8</span> <code>build</code></h4>
<div class="outline-text-4" id="text-3-1-8">
<p>
Dockerfile 파일을 이미지로 생성한다.
</p>
</div>
<div id="outline-container-org73afb3e" class="outline-5">
<h5 id="org73afb3e"><span class="section-number-5">3.1.8.1</span> Dockerfile</h5>
<div class="outline-text-5" id="text-3-1-8-1">
<p>
Dockerfile 파일은 docker 이미지를 생성할 수 있는 파일이다. Dockerfile의 문법에 맞춰서 작성하면 <code>build</code> 명령을 통해 원하는 이미지를 만들 수 있다. 아래는 필자가 사용하는 Dockerfile 파일 중 하나로써 Ubuntu 18.04와 ROS를 자동으로 설치해준다.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">this Dockerfile creates an Ubuntu 18.04 environment with ROS melodic.</span>
FROM ubuntu:18.04
ENV DEBIAN_FRONTEND noninteractive

<span class="org-comment-delimiter"># </span><span class="org-comment">install dependencies via apt</span>
ENV DEBCONF_NOWARNINGS yes
RUN set -x &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt update -y -qq &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt upgrade -y -qq --no-install-recommends &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"basic dependencies"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt install -y -qq build-essential pkg-config cmake git wget curl tar unzip &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"g2o dependencies"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt install -y -qq libgoogle-glog-dev libatlas-base-dev libsuitesparse-dev &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"OpenCV dependencies"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt install -y -qq libgtk-3-dev libjpeg-dev libpng++-dev libtiff-dev libopenexr-dev libwebp-dev ffmpeg libavcodec-dev libavformat-dev libavutil-dev libswscale-dev libavresample-dev &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"Pangolin dependencies"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt install -y -qq libglew-dev &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"other dependencies"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt install -y -qq libyaml-cpp-dev &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    : <span class="org-string">"remove cache"</span> &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    apt autoremove -y -qq &amp;&amp; rm -rf /var/lib/apt/lists/*

ARG <span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>=/usr/local
ARG <span class="org-variable-name">NUM_THREADS</span>=7

ENV <span class="org-variable-name">CPATH</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/include:${<span class="org-variable-name">CPATH</span>}
ENV <span class="org-variable-name">C_INCLUDE_PATH</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/include:${<span class="org-variable-name">C_INCLUDE_PATH</span>}
ENV <span class="org-variable-name">CPLUS_INCLUDE_PATH</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/include:${<span class="org-variable-name">CPLUS_INCLUDE_PATH</span>}
ENV <span class="org-variable-name">LIBRARY_PATH</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/lib:${<span class="org-variable-name">LIBRARY_PATH</span>}
ENV <span class="org-variable-name">LD_LIBRARY_PATH</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/lib:${<span class="org-variable-name">LD_LIBRARY_PATH</span>}

ENV NVIDIA_VISIBLE_DEVICES ${<span class="org-variable-name">NVIDIA_VISIBLE_DEVICES</span>:-all}
ENV NVIDIA_DRIVER_CAPABILITIES ${<span class="org-variable-name">NVIDIA_DRIVER_CAPABILITIES</span>:+$<span class="org-variable-name">NVIDIA_DRIVER_CAPABILITIES</span>,}graphics

<span class="org-comment-delimiter"># </span><span class="org-comment">Eigen</span>
ARG <span class="org-variable-name">EIGEN3_VERSION</span>=3.3.7
WORKDIR /tmp
RUN set -x &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    wget -q https://gitlab.com/libeigen/eigen/-/archive/${<span class="org-variable-name">EIGEN3_VERSION</span>}/eigen-${<span class="org-variable-name">EIGEN3_VERSION</span>}.tar.bz2 &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    tar xf eigen-${<span class="org-variable-name">EIGEN3_VERSION</span>}.tar.bz2 &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    rm -rf eigen-${<span class="org-variable-name">EIGEN3_VERSION</span>}.tar.bz2 &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    <span class="org-builtin">cd</span> eigen-${<span class="org-variable-name">EIGEN3_VERSION</span>} &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    mkdir -p build &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    <span class="org-builtin">cd</span> build &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    cmake <span class="org-sh-escaped-newline">\</span>
        -DCMAKE_BUILD_TYPE=Release <span class="org-sh-escaped-newline">\</span>
        -DCMAKE_INSTALL_PREFIX=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>} <span class="org-sh-escaped-newline">\</span>
        .. &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    make -j${<span class="org-variable-name">NUM_THREADS</span>} &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    make install &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    <span class="org-builtin">cd</span> /tmp &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    rm -rf *
ENV <span class="org-variable-name">Eigen3_DIR</span>=${<span class="org-variable-name">CMAKE_INSTALL_PREFIX</span>}/share/eigen3/cmake

<span class="org-comment-delimiter"># </span><span class="org-comment">ROS</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">install packages</span>
RUN apt update &amp;&amp; apt install -q -y <span class="org-sh-escaped-newline">\</span>
                              dirmngr <span class="org-sh-escaped-newline">\</span>
                              gnupg2 <span class="org-sh-escaped-newline">\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*

<span class="org-comment-delimiter"># </span><span class="org-comment">setup keys</span>
RUN apt-key adv --keyserver <span class="org-string">'hkp://keyserver.ubuntu.com:80'</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654

<span class="org-comment-delimiter"># </span><span class="org-comment">setup sources.list</span>
RUN echo <span class="org-string">"deb http://packages.ros.org/ros/ubuntu bionic main"</span> &gt; /etc/apt/sources.list.d/ros1-latest.list

<span class="org-comment-delimiter"># </span><span class="org-comment">install bootstrap tools</span>
RUN apt update &amp;&amp; apt install --no-install-recommends -y <span class="org-sh-escaped-newline">\</span>
                              python-rosdep <span class="org-sh-escaped-newline">\</span>
                              python-rosinstall <span class="org-sh-escaped-newline">\</span>
                              python-vcstools <span class="org-sh-escaped-newline">\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*

<span class="org-comment-delimiter"># </span><span class="org-comment">setup environment</span>
ENV LANG C.UTF-8
ENV LC_ALL C.UTF-8

<span class="org-comment-delimiter"># </span><span class="org-comment">bootstrap rosdep</span>
RUN rosdep init <span class="org-sh-escaped-newline">\</span>
    &amp;&amp; rosdep update

<span class="org-comment-delimiter"># </span><span class="org-comment">install ros packages</span>
ENV ROS_DISTRO melodic
RUN apt update &amp;&amp; apt install -y <span class="org-sh-escaped-newline">\</span>
                              ros-melodic-ros-core <span class="org-sh-escaped-newline">\</span>
                              ros-melodic-desktop-full <span class="org-sh-escaped-newline">\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*


<span class="org-comment-delimiter"># </span><span class="org-comment">run opengl program (e.g., rviz) on docker </span>
RUN apt update &amp;&amp; apt install -y --no-install-recommends <span class="org-sh-escaped-newline">\</span>
                              pkg-config <span class="org-sh-escaped-newline">\</span>
                              libxau-dev <span class="org-sh-escaped-newline">\</span>
                              libxdmcp-dev <span class="org-sh-escaped-newline">\</span>
                              libxcb1-dev <span class="org-sh-escaped-newline">\</span>
                              libxext-dev <span class="org-sh-escaped-newline">\</span>
                              libx11-dev &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    rm -rf /var/lib/apt/lists/*

COPY --from=nvidia/opengl:1.0-glvnd-runtime-ubuntu18.04 <span class="org-sh-escaped-newline">\</span>
     /usr/lib/x86_64-linux-gnu <span class="org-sh-escaped-newline">\</span>
     /usr/lib/x86_64-linux-gnu

COPY --from=nvidia/opengl:1.0-glvnd-runtime-ubuntu18.04 <span class="org-sh-escaped-newline">\</span>
     /usr/share/glvnd/egl_vendor.d/10_nvidia.json <span class="org-sh-escaped-newline">\</span>
     /usr/share/glvnd/egl_vendor.d/10_nvidia.json

RUN echo <span class="org-string">'/usr/lib/x86_64-linux-gnu'</span> &gt;&gt; /etc/ld.so.conf.d/glvnd.conf &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    ldconfig &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    <span class="org-builtin">echo</span> <span class="org-string">'/usr/lib/x86_64-linux-gnu/libGL.so.1'</span> &gt;&gt; /etc/ld.so.preload &amp;&amp; <span class="org-sh-escaped-newline">\</span>
    <span class="org-builtin">echo</span> <span class="org-string">'/usr/lib/x86_64-linux-gnu/libEGL.so.1'</span> &gt;&gt; /etc/ld.so.preload

<span class="org-comment-delimiter"># </span><span class="org-comment">Finish-----------------</span>
WORKDIR /root
ENTRYPOINT [<span class="org-string">"/bin/bash"</span>]
</pre>
</div>

<p>
위와 같이 Dockerfile을 작성하고 파일이 존재하는 폴더에서 다음 명령을 실행하면 빌드된다.
</p>
<div class="org-src-container">
<pre class="src src-sh">$ docker build -t sample:0.1 -f Dockerfile .
<span class="org-comment-delimiter"># </span><span class="org-comment">-t(--tag) &#50741;&#49496;&#51004;&#47196; &#51060;&#48120;&#51648; &#51060;&#47492;&#44284; &#53468;&#44536;&#47484; &#49444;&#51221;&#54624; &#49688; &#51080;&#45796;. &#51060;&#48120;&#51648; &#51060;&#47492;&#47564; &#49444;&#51221;&#54616;&#47732; &#53468;&#44536;&#45716; latest&#47196; &#49444;&#51221;&#46108;&#45796;.</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">&#51104;&#49884; &#44592;&#45796;&#47532;&#47732; &#51060;&#48120;&#51648;&#44032; &#49373;&#49457;&#46108;&#45796;. &#50500;&#47000; &#47749;&#47161;&#50612;&#47196; &#51060;&#48120;&#51648; &#47785;&#47197;&#51012; &#52636;&#47141;&#54620;&#45796;.</span>
$ docker images

<span class="org-comment-delimiter"># </span><span class="org-comment">run &#47749;&#47161;&#51012; &#53685;&#54644; &#51060;&#48120;&#51648;&#47484; &#49892;&#54665;&#54624; &#49688; &#51080;&#45796;.</span>
$ docker run --name sample -d -p 80:80 -v /root/data:/data sample:0.1
<span class="org-comment-delimiter"># </span><span class="org-comment">&#51088;&#49464;&#54620; &#50741;&#49496;&#46308;&#51032; &#51032;&#48120;&#45716; &#45796;&#51020;&#44284; &#44057;&#45796;.</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-d : &#52968;&#53580;&#51060;&#45320;&#47484; &#48177;&#44536;&#46972;&#50868;&#46300;&#47196; &#49892;&#54665;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-p 80:80 : &#54840;&#49828;&#53944;&#51032; 80&#48264; &#54252;&#53944;&#50752; &#52968;&#53580;&#51060;&#45320;&#51032; 80&#48264; &#54252;&#53944;&#47484; &#50672;&#44208;&#54616;&#44256; &#50808;&#48512;&#50640; &#45432;&#52636;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">-v /root/data:/data : &#54840;&#49828;&#53944;&#51032; /root/data &#46356;&#47113;&#53664;&#47532;&#47484; &#52968;&#53580;&#51060;&#45320;&#51032; /data &#46356;&#47113;&#53664;&#47532;&#50640; &#50672;&#44208;</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfd39baa" class="outline-4">
<h4 id="orgfd39baa"><span class="section-number-4">3.1.9</span> <code>push, pull</code></h4>
<div class="outline-text-4" id="text-3-1-9">
<p>
git의 pull, push와 동일하게 원격 hub로부터 이미지를 가져오거나 저장
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">&#50896;&#44201; dockerhub&#50640;&#49436; &#53945;&#51221; &#51060;&#48120;&#51648;&#47484; &#48155;&#50500;&#50740;</span>
$ docker pull ubuntu:18.04
</pre>
</div>
</div>
<div id="outline-container-orgcad75ad" class="outline-5">
<h5 id="orgcad75ad"><span class="section-number-5">3.1.9.1</span> Docker hub</h5>
<div class="outline-text-5" id="text-3-1-9-1">
<p>
docker도 github처럼 저장소 사이트가 존재한다. <a href="https://hub.docker.com">해당 사이트</a>에 가입하고 Pull, Push 명령어를 통해 원격저장소와 데이터를 주고 받을 수 있다. 
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Docker hub &#44228;&#51221; &#47196;&#44536;&#51064;</span>
$ docker login

<span class="org-comment-delimiter"># </span><span class="org-comment">&#47196;&#52972;&#50640; &#51316;&#51116;&#54616;&#45716; edward0im/1804:scratch &#51060;&#48120;&#51648;&#47484; &#50896;&#44201;&#51200;&#51109;&#49548;&#50640; Push&#54620;&#45796;</span>
$ docker push edward0im/1804:scratch

<span class="org-comment-delimiter"># </span><span class="org-comment">&#50896;&#44201;&#50640; &#51316;&#51116;&#54616;&#45716; edward0im/1804:scratch &#51060;&#48120;&#51648;&#47484; &#47196;&#52972;&#51200;&#51109;&#49548;&#50640; Pull&#54620;&#45796;.</span>
$ docker pull edward0im/1804:scratch
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaea77e2" class="outline-4">
<h4 id="orgaea77e2"><span class="section-number-4">3.1.10</span> <code>&lt;C-p&gt; &lt;C-q&gt;</code></h4>
<div class="outline-text-4" id="text-3-1-10">
<p>
docker 컨테이너를 종료하지 않은 상태로 빠져나온다. 컨테이너는 백그라운드에서 계속 실행 상태에 있으며 다시 <code>attach</code> 명령을 통해 접속할 수 있다.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf163f42" class="outline-2">
<h2 id="orgf163f42"><span class="section-number-2">4</span> References</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li><a href="https://www.slideshare.net/pyrasis/docker-fordummies-44424016">도커 무작정 따라하기</a></li>
<li><a href="https://ykarma1996.tistory.com/92">docker 컨테이너에서 GPU 사용 - ykarma1996 blog</a></li>
<li><a href="https://blog.neonkid.xyz/87">Docker 네트워크 구성과 설정 - neonkid blog</a></li>
</ol>
</div>
</div>
